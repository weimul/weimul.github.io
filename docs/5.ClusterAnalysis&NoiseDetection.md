# 5 聚类分析和噪声检测



## 层次聚类

对给定的数据集进行层次分解，直到某种条件满足。

- 分为凝聚和分裂两种策略

### AGNES算法

自底向上凝聚算法代表

### DIANA算法

自顶向下分裂算法代表

- 输入：包含n个对象的数据库，终止条件簇的数目k

- 输出：k个簇，达到终止条件规定簇数目

- #### DIANA伪代码：

1. **将所有对象整个当成一个簇**

2. `FOR  (i=1; i!=k; i++) DO BEGIN`

   ​		`在所有簇中挑出具有最大直径的簇C；`

   ​		`找出C中与其他点平均相异度最大的一个点p并把p放入splinter group，剩余的放在old party中`

   ​		`REPEAT`
   ​				`在old party中找到最近的splinter group中的点的距离不大于到old party中最近点的点，并将该点加入splinter group`
   ​		`UNTIL (没有新的old party的点被分配给splinter group)`

   ​		`splinter group和old party为被选中的簇分裂成的两个簇，与其他簇一起组成新的簇集合`

   `END`

## 密度聚类

1. 思想：只要一个区域中的点的密度大于某个阈值，就把它加到与之相近的聚类中去。
2. 优点：可发现任意形状的聚类；对噪声数据不敏感
3. 缺点：计算复杂度大；对数据维数的伸缩性较差；需要扫描整个数据库-频繁的I/O操作；超参数敏感，。

### DBSCAN算法

- 簇定义：一个基于密度的簇是基于密度可达性的最大的密度相连对象的集合
- 利用类的高密度连通性，快速发现任意形状的类：
  - 在一个数据空间汇中，高密度区总是被低密度区所分割
  - 它能够从含有噪声的空间数据中发现任意形状的聚类

- #### DBSCAN基本定义

1. **对象的$\\epsilon$-邻域(Eps近邻)：给定对象在半径$\\epsilon$内的区域**
2. 核心对象：$\\epsilon$-邻域至少包含最小数目MinPts个对象的一个对象
3. 直接密度可达：给定一个对象集合D，如果p是在q的$\\epsilon$-邻域内，而q是一个核心对象，则对象p从对象q出发是直接密度可达的
4. 密度可达：如果存在一个对象链p~1~,p~2~,...,p~n~, p~1~=q,p~n~=p,对p~i~$\\in$D,(i<=i<=n), p~i+1~是从pi关于$\epsilon$和MinPts直接密度可达，则对象p是从对象q关于$\\epsilon$和MinPts密度可达的。
5. 密度相连：如果对象集合D中存在一个对象o，使得对象p和q是从o关于$\\epsilon$和MinPts密度可达的，那么对象p和q是关于$\epsilon$和MinPts密度相连的。
6. 噪声：不包含在任何簇中的对象被认为是”噪声“。

- #### DBSCAN算法伪代码

  - 输入：包含n个对象的数据库，半径$\\epsilon$，最少数目MinPts。
  - 输出：所有达到密度要求的生成的簇。

​	`REPEAT`
​		`从数据库中抽取一个未处理的点`
​		`IF(抽出的点是核心点):`
​			`找出所有从该点密度可达的对象，形成一个簇`
​	`UNTIL 所有的点都被处理`

## 网格聚类

1. 思想：将对象空间量化为有限数目的单元，形成一个网格结构，聚类在此基础上进行

2. 优点：处理速度快，处理时间独立于数据对象规模，只与量化空间中每一维的单元数目有关；网格结构利于并行和增量更新。

   > 产生聚类的时间复杂度为O(n)，查询的时间复杂度为O(g)，g远小于n。

### STING算法

- 主要利用网格单元中的统计信息进行聚类
- 结构设计：基于网格的多分辨率聚类技术，将空间区域分为矩形单元。针对不同级别的分辨率，通常存在<u>多个级别的矩形单元</u>。
  ![image-20230404202232736](C:\Users\23237\AppData\Roaming\Typora\typora-user-images\image-20230404202232736.png)这些单元形成了一个层次结构：高层的每个单元被划分为多个低一层的单元。高层单元的统计参数可以很容易的从底层单元的计算得到。![image-20230404202245668](C:\Users\23237\AppData\Roaming\Typora\typora-user-images\image-20230404202245668.png)

- 参数：属性无关的参数count、属性相关的参数m（平均值）、s(标准偏差)、min(最小值)、max(最大值)以及该单元中属性值遵循的分布类型。

#### STING算法伪代码

1. 从一个层次开始，对于所有相关单元格（首层默认设置为全相关），计算查询相关的属性值
2. 从计算的属性值以及约束条件下，我们将每一个单元格标记成相关或不相关
3. 如果本层为底层，转到(5)，否则转(4)
4. 层次结构转到下层，转(2)
5. 查询结果得到满足，转(7),否则(6)
6. 恢复数据到相关的单元格进一步处理以得到满足的结果，转(7)
7. 结束

- 总结：STING采用多分辨率的方法进行聚类
  算法质量取决于网格结构最底层的粒度。

## 离群点（孤立点）的检测

1. 离群点：显著不同于其它数据对象的数据对象。
2. 类型包括：全局离群点、情景离群点、集体离群点。
3. 异常数据的意义和价值：
   - 常规模式的挖掘：异常数据作为噪音而忽略
   - 异常检测领域：异常数据是主要研究对象
4. 基于数据可视化的离群点探测
   - 不适用包含周期性曲线的数据
   - 对于多分类属性的数据和高维数据的离群点探测效率很低
5. 常用方法包括统计学方法、基于距离的方法、基于偏差的方法和基于密度的方法。

### 基于统计学的孤立点检测

思想：对于给定的数据集假设一个分布或概率模型（如正态分布），然后根据模型采用不一致性检验（discordancy test）来确定离群点。

> 其实就是假设检验的方法

参数要求：数据集分布，分布参数，预期离群点数量

缺点：

- 大多数检验是针对单个属性，而数据挖掘问题要求在多维空间检测
- 统计学方法关于数据集合参数知识的要求很难达到，如观察的分布不易被任何标准分布模拟。
- 没有特定检验时，该方法不能保证检测出所有的离群点

### 基于距离的孤立点检测

思路：孤立点是没有足够多“邻居”的对象

定义：基于距离的孤立点：DB($r,\pi$)是数据集$T$中的一个对象$o$，使得$T$中的对象至少有$\pi$部分与$o$的距离大于$r$

> 对许多不一致性检验来说, 如果一个对象 o根据给定的检验是一个孤立点, 那么对恰当定义的π和r，o也是一个DB(r, π) 孤立点

#### 算法

##### 基于索引的算法

采用多维索引结构，R树或K-D树，来查找每个对象o在半径r内范围的邻居

设M是一个孤立点的r-邻域内的最大对象数目，一旦对象o的M+1个邻居被发现，o就不是孤立点

##### 嵌套循环算法

两层循环来计算DB (r, π)-孤立点，复杂度O(n^2^);

通过找某个半径内的对象个数，如果超出个数，则退出内循环。

##### 基于单元（cell-based）的算法

###### 方法

数据空间被划分为单元；
每个单元有两层围绕着；
算法逐个单元地对孤立点计算，而不是逐个对象地进行计算. 对一个给定的单元, 它累计三个计数——单元中对象的数目 , 单元和第一层中对象的数目, 及单元和两个层次中的对象的数目

###### 孤立点确定

设M是一个孤立点的r-邻域中可能存在的孤立点的最大数目 

如果单元和第一层中对象的数目大于M, 那么该单元中所有的对象可以从进一步的考察中移走, 因为它们不可能是孤立点；
如果单元和两个层次中的对象的数目小于或等于M，那么单元中所有的对象被认为是孤立点；
否则, 对单元中的每个对象o, 检查o的第二层中的对象.   只有那些r-邻域内的对象不超过M个的点是孤立点 

###### 单元划分

数据空间被划分为边长为r/(2(k)^1/2^)的单元；
每个单元有两个包围层：第一层为1倍的单元厚；第二层为int（2 k^1/2^ -1）+1倍的单元厚![image-20230404205949772](C:\Users\23237\AppData\Roaming\Typora\typora-user-images\image-20230404205949772.png)

###### 确定异常

若cell + 1_layer_count>M，单元中的对象都不是异常；
若cell + 2_layer_count<=M，单元中的所有对象都是异常；
否则，单元中的一些对象可能为异常，逐个对象进行处理。

### 基于偏离的孤立点检测

